import { IEyeglass } from "../IEyeglass";
import { AssetSourceOptions } from "../util/Options";
import { SassImplementation } from "../util/SassImplementation";
import * as sass from "node-sass";
import AssetsCollection from "./AssetsCollection";
import AssetsSource from "./AssetsSource";
interface Resolution {
    path: string;
    query?: string;
}
declare type ResolverCallback = (error: unknown, result: Resolution | undefined) => unknown;
declare type Resolver = (assetFile: string, assetUri: string, cb: ResolverCallback) => void;
declare type WrappedResolver = (assetFile: string, assetUri: string, fallback: Resolver, cb: ResolverCallback) => void;
interface Resolves {
    resolve: Resolver;
}
declare type InstallerCallback = (error: unknown, dest?: string) => void;
declare type Installer = (file: string, uri: string, cb: InstallerCallback) => void;
declare type WrappedInstaller = (file: string, uri: string, fallback: Installer, cb: InstallerCallback) => void;
interface Installs {
    install: Installer;
}
export default class Assets implements Resolves, Installs {
    sassUtils: any;
    eyeglass: IEyeglass;
    /**
     * Assets declared by the application.
     */
    collection: AssetsCollection;
    /**
     * Assets declared by eyeglass modules.
     */
    moduleCollections: Array<AssetsCollection>;
    AssetCollection: () => AssetsCollection;
    AssetPathEntry: (src: string, options: AssetSourceOptions) => AssetsSource;
    constructor(eyeglass: IEyeglass, sass: SassImplementation);
    /**
      * @see AssetsCollection#asAssetImport
      */
    asAssetImport(name: string | undefined): string;
    /**
      * @see AssetsCollection#addSource
      */
    addSource(src: string, opts: Partial<AssetSourceOptions>): AssetsCollection;
    /**
      * @see AssetsCollection#cacheKey
      */
    cacheKey(name: string): string;
    /**
      * creates a new AssetsCollection and adds the given source
      * @see #addSource
      * @param    {String} src - the source directory
      * @param    {Object} opts - the options
      * @returns  {AssetsCollection} the instance of the AssetsCollection
      */
    export(src: string, opts: AssetSourceOptions): AssetsCollection;
    /**
      * resolves an asset given a uri
      * @param    {SassMap} $assetsMap - the map of registered Sass assets
      * @param    {SassString} $uri - the uri of the asset
      * @param    {Function} cb - the callback that is invoked when the asset resolves
      */
    resolveAsset($assetsMap: sass.types.Map, $uri: sass.types.Value, cb: (error: Error | null, uri?: string, file?: string) => unknown): void;
    /**
      * resolves the asset uri
      * @param    {String} assetFile - the source file path
      * @param    {String} assetUri - the resolved uri path
      * @param    {Function} cb - the callback to pass the resolved uri to
      */
    resolve(_assetFile: string, assetUri: string, cb: ResolverCallback): void;
    /**
      * wraps the current resolver with a custom resolver
      * @param    {Function} resolver - the new resolver function
      */
    resolver(resolver: WrappedResolver): void;
    /**
      * installs the given asset
      * @param    {String} file - the source file path to install from
      * @param    {String} uri - the resolved uri path
      * @param    {Function} cb - the callback invoked after the installation is successful
      */
    install(file: string, uri: string, cb: InstallerCallback): void;
    /**
      * wraps the current installer with a custom installer
      * @param    {Function} installer - the new installer function
      */
    installer(installer: WrappedInstaller): void;
    private resolveAssetDefaults;
}
export {};
//# sourceMappingURL=Assets.d.ts.map