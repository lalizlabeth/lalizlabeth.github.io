"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("../util/debug");
var URI_1 = require("../util/URI");
var merge = require("lodash.merge");
var typescriptUtils_1 = require("../util/typescriptUtils");
var ImportUtilities = /** @class */ (function () {
    function ImportUtilities(eyeglass, sass, options, fallbackImporter, context) {
        this.root = options.eyeglass.root;
        this.eyeglass = eyeglass;
        this.sass = sass;
        this.fallbackImporter = fallbackImporter;
        this.options = options;
        this.context = merge(context, {
            eyeglass: {
                imported: {} // keep track of files already imported @see importOnce
            }
        });
    }
    ImportUtilities.createImporter = function (importer) {
        return function (uri, prev, done) {
            uri = URI_1.URI.web(uri);
            prev = URI_1.URI.system(prev);
            importer.call(this, uri, prev, done);
        };
    };
    ImportUtilities.prototype.importOnce = function (data, done) {
        if (this.options.eyeglass.enableImportOnce && this.context.eyeglass.imported[data.file]) {
            // log that we've already imported this file
            /* istanbul ignore next - don't test debug */
            debug.importer("%s was already imported", data.file);
            done({ contents: "", file: "already-imported:" + data.file });
        }
        else {
            this.context.eyeglass.imported[data.file] = true;
            done(data);
        }
    };
    ImportUtilities.prototype.fallback = function (uri, prev, done, noFallback) {
        var _this = this;
        if (Array.isArray(this.fallbackImporter)) {
            if (this.fallbackImporter.length > 0) {
                this.fallbackNth(uri, prev, 0, done, noFallback);
            }
            else {
                noFallback.call(this.context);
            }
        }
        else if (typescriptUtils_1.isPresent(this.fallbackImporter)) {
            this.fallbackImporter.call(this.context, uri, prev, function (result) {
                if (result === _this.sass.NULL || !result) {
                    noFallback.call(_this.context);
                }
                else {
                    done(result);
                }
            });
        }
        else {
            noFallback.call(this.context);
        }
    };
    ImportUtilities.prototype.fallbackNth = function (uri, prev, index, done, noFallback) {
        var _this = this;
        if (!Array.isArray(this.fallbackImporter)) {
            return done(new Error("[internal error] fallbackNth can only be called for a list of fallbacks."));
        }
        var fallbackImporter = this.fallbackImporter[index];
        // TODO (test) - how do we get into this condition? needs a test case
        if (!fallbackImporter) {
            noFallback.call(this.context);
        }
        else {
            fallbackImporter.call(this.context, uri, prev, function (result) {
                if (result === _this.sass.NULL || !result) {
                    _this.fallbackNth(uri, prev, index + 1, done, noFallback);
                }
                else {
                    done(result);
                }
            });
        }
    };
    return ImportUtilities;
}());
exports.default = ImportUtilities;
//# sourceMappingURL=ImportUtilities.js.map