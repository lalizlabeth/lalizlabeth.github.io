"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path = require("path");
var NameExpander_1 = require("../util/NameExpander");
var ImportUtilities_1 = require("./ImportUtilities");
var assertions_1 = require("../util/assertions");
var typescriptUtils_1 = require("../util/typescriptUtils");
var errorFor_1 = require("../util/errorFor");
var MODULE_PARSER = /^((?:@[^/]+\/[^/]+)|(?:[^/]+))\/?(.*)/;
/*
 * Walks the file list until a match is found. If
 * no matches are found, calls the callback with an error
 */
function readFirstFile(uri, possibleFiles, callback) {
    var e_1, _a, _b;
    try {
        for (var possibleFiles_1 = __values(possibleFiles), possibleFiles_1_1 = possibleFiles_1.next(); !possibleFiles_1_1.done; possibleFiles_1_1 = possibleFiles_1.next()) {
            var nextFile = possibleFiles_1_1.value;
            try {
                var data = fs_1.readFileSync(nextFile, "utf8");
                // if it didn't fail, we found the first file so return it
                callback(null, {
                    contents: data.toString(),
                    file: nextFile
                });
                return;
            }
            catch (_c) {
                // pass
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (possibleFiles_1_1 && !possibleFiles_1_1.done && (_a = possibleFiles_1.return)) _a.call(possibleFiles_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var errorMsg = (_b = [
        "`" + uri + "` was not found in any of the following locations:"
    ]).concat.apply(_b, __spread(possibleFiles)).join("\n  ");
    callback(new Error(errorMsg));
    return;
}
// This is a bootstrap function for calling readFirstFile.
function readAbstractFile(originalUri, uri, location, includePaths, moduleName, callback) {
    // start a name expander to get the names of possible file locations
    var nameExpander = new NameExpander_1.NameExpander(uri);
    // add the current location to the name expander
    nameExpander.addLocation(location);
    // if we have a module name, add it as an additional location
    if (moduleName) {
        nameExpander.addLocation(path.join(location, moduleName));
    }
    // if we have includePaths...
    if (includePaths) {
        // add each of includePaths to the name expander
        includePaths.forEach(function (includePath) {
            nameExpander.addLocation(path.resolve(location, includePath));
        });
    }
    readFirstFile(originalUri, nameExpander.files, callback);
}
/*
 * Returns an importer suitable for passing to node-sass.
 * options are the eyeglass/node-sass options.
 * fallback importer is the importer that was specified
 * in the node-sass options if one was there.
 */
var ModuleImporter = function (eyeglass, sass, options, fallbackImporter) {
    var includePaths = options.includePaths;
    var root = options.eyeglass.root;
    return ImportUtilities_1.default.createImporter(function (uri, prev, done) {
        var importUtils = new ImportUtilities_1.default(eyeglass, sass, options, fallbackImporter, this);
        var isRealFile = fs_1.existsSync(prev);
        // pattern to match moduleName/relativePath
        // $1 = moduleName (foo or @scope/foo)
        // $2 = relativePath
        var match = MODULE_PARSER.exec(uri);
        if (!match) {
            throw new Error("invalid uri: " + uri);
        }
        var moduleName = match[1];
        var relativePath = match[2];
        var mod = eyeglass.modules.access(moduleName, isRealFile ? prev : root);
        // for back-compat with previous suggestion @see
        // https://github.com/sass-eyeglass/eyeglass/issues/131#issuecomment-210728946
        // if the module was not found and the name starts with `@`...
        if (!mod && moduleName[0] === "@") {
            // reconstruct the moduleName and relativePath the way we would have previously
            var pieces = moduleName.split("/");
            relativePath = pieces[1] + "/" + relativePath;
            moduleName = pieces[0];
            // and try to find it again
            mod = eyeglass.modules.access(moduleName, isRealFile ? prev : root);
        }
        var sassDir;
        if (mod) {
            sassDir = mod.sassDir;
            if (!sassDir && !isRealFile) {
                // No sass directory, give an error
                importUtils.fallback(uri, prev, done, function () {
                    if (!mod) {
                        return assertions_1.unreachable();
                    }
                    var missingMessage = "sassDir is not specified in " + mod.name + "'s package.json";
                    if (mod.mainPath) {
                        missingMessage += " or " + mod.mainPath;
                    }
                    return done(new Error(missingMessage));
                });
                return;
            }
        }
        function createHandler(errorHandler) {
            var errHandler = errorHandler || defaultErrorHandler(done);
            return function (err, data) {
                if (err || !typescriptUtils_1.isPresent(data)) {
                    importUtils.fallback(uri, prev, done, function () {
                        errHandler(err || "[internal error] No data returned.");
                    });
                }
                else {
                    importUtils.importOnce(data, done);
                }
            };
        }
        function handleRelativeImports(includePaths) {
            if (includePaths === void 0) { includePaths = null; }
            if (isRealFile) {
                // relative file import, potentially relative to the previous import
                readAbstractFile(uri, uri, path.dirname(prev), includePaths, null, createHandler());
            }
            else {
                readAbstractFile(uri, uri, root, includePaths, null, createHandler(function (err) {
                    done(errorFor_1.default(err, "Could not import " + uri + " from " + prev));
                }));
            }
        }
        if (sassDir) {
            // read uri from location. pass no includePaths as this is an eyeglass module
            readAbstractFile(uri, relativePath, sassDir, null, moduleName, createHandler(
            // if it fails to find a module import,
            //  try to import relative to the current location
            // this handles #37
            handleRelativeImports.bind(null, null)));
        }
        else {
            handleRelativeImports(includePaths);
        }
    });
};
function defaultErrorHandler(done) {
    return function (err) {
        done(errorFor_1.default(err));
    };
}
exports.default = ModuleImporter;
//# sourceMappingURL=ModuleImporter.js.map