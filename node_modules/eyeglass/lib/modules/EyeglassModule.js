"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var packageUtils = require("../util/package");
var merge = require("lodash.merge");
var includes = require("lodash.includes");
var path = require("path");
var fs = require("fs");
var typescriptUtils_1 = require("../util/typescriptUtils");
var rInvalidName = /\.(?:sass|s?css)$/;
var EYEGLASS_KEYWORD = "eyeglass-module";
function isModuleReference(mod) {
    return typeof mod === "object" && !!mod["path"];
}
var EyeglassModule = /** @class */ (function () {
    function EyeglassModule(modArg, discoverModules, isRoot) {
        if (isRoot === void 0) { isRoot = false; }
        // some defaults
        var mod = merge({
            eyeglass: {}
        }, modArg);
        // if we were given a path, resolve it to the package.json
        if (isModuleReference(mod)) {
            var pkg = packageUtils.getPackage(mod.path);
            // if pkg.data is empty, this is an invalid path, so throw an error
            if (!pkg.data) {
                throw new Error("Could not find a valid package.json at " + mod.path);
            }
            var modulePath = fs.realpathSync(path.dirname(pkg.path));
            mod = merge({
                isEyeglassModule: EyeglassModule.isEyeglassModule(pkg.data),
                inDevelopment: false,
                isRoot: isRoot
            }, mod, {
                path: modulePath,
                name: getModuleName(pkg.data),
                rawName: pkg.data.name,
                version: pkg.data.version,
                // only resolve dependencies if we were given a discoverModules function
                dependencies: discoverModules && discoverModules({
                    dir: modulePath,
                    isRoot: isRoot
                }) || mod.dependencies,
                eyeglass: normalizeEyeglassOptions(pkg.data.eyeglass, modulePath)
            });
            if (mod.isEyeglassModule) {
                var moduleMain = getModuleExports(pkg.data, modulePath);
                var mainInfo = {
                    main: moduleMain && require(moduleMain) || null,
                    mainPath: moduleMain
                };
                merge(mod, mainInfo);
                if (rInvalidName.test(mod.name)) {
                    throw new Error("An eyeglass module cannot contain an extension in it's name: " + mod.name);
                }
            }
        }
        // if a sassDir is specified in eyeglass options, it takes precedence
        mod.sassDir = mod.eyeglass.sassDir || mod.sassDir;
        // set the rawName if it's not already set
        mod.rawName = mod.rawName || mod.name;
        // these are handled by merge but are here to make the compiler happy
        // TODO: Rewrite this to not use the intermediate object.
        this.dependencies = mod.dependencies;
        this.eyeglass = mod.eyeglass;
        this.isEyeglassModule = mod.isEyeglassModule;
        this.name = mod.name;
        this.path = mod.path;
        this.rawName = mod.rawName;
        this.version = mod.version;
        this.inDevelopment = mod.inDevelopment;
        this.isRoot = mod.isRoot;
        // merge the module properties into the instance
        merge(this, mod);
    }
    /**
      * initializes the module with the given engines
      *
      * @param   {Eyeglass} eyeglass - the eyeglass instance
      * @param   {Function} sass - the sass engine
      */
    EyeglassModule.prototype.init = function (eyeglass, sass) {
        merge(this, this.main && this.main(eyeglass, sass));
    };
    /**
      * whether or not the given package is an eyeglass module
      *
      * @param   {Object} pkg - the package.json
      * @returns {Boolean} whether or not it is an eyeglass module
      */
    EyeglassModule.isEyeglassModule = function (pkg) {
        return !!(typescriptUtils_1.isPresent(pkg) && includes(pkg.keywords, EYEGLASS_KEYWORD));
    };
    return EyeglassModule;
}());
exports.default = EyeglassModule;
/**
  * given a package.json reference, gets the Eyeglass module name
  *
  * @param   {Object} pkg - the package.json reference
  * @returns {String} the name of the module
  */
function getModuleName(pkg) {
    // check for `eyeglass.name` first, otherwise use `name`
    return normalizeEyeglassOptions(pkg.eyeglass).name || pkg.name;
}
/**
  * normalizes a given `eyeglass` reference from a package.json
  *
  * @param   {Object} options - The eyeglass options from the package.json
  * @param   {String} pkgPath - The location of the package.json.
  * @returns {Object} the normalized options
  */
function normalizeEyeglassOptions(options, pkgPath) {
    var normalizedOpts;
    if (typeof options === "object") {
        normalizedOpts = options;
    }
    else if (typeof options === "string") {
        // if it's a string, treat it as the export
        normalizedOpts = {
            exports: options
        };
    }
    else {
        normalizedOpts = {};
    }
    if (pkgPath && normalizedOpts.sassDir) {
        normalizedOpts.sassDir = path.resolve(pkgPath, normalizedOpts.sassDir);
    }
    return normalizedOpts;
}
/**
  * gets the export from a given `eyeglass` reference from a package.json
  *
  * @param   {Object} options - the eyeglass options from the package.json
  * @returns {Object} the normalized options
  */
function getExportsFileFromOptions(options) {
    return normalizeEyeglassOptions(options).exports;
}
/**
  * gets the export for a given package.json
  *
  * @param   {Object} pkg - the package.json
  * @param   {String} modulePath - the path to the module
  * @returns {String} the export file to use
  */
function getModuleExports(pkg, modulePath) {
    var exportsFile = getExportsFileFromOptions(pkg.eyeglass);
    if (exportsFile === false) {
        return null;
    }
    else {
        exportsFile = exportsFile || pkg.main;
    }
    if (exportsFile) {
        return path.join(modulePath, exportsFile);
    }
    else {
        return null;
    }
}
//# sourceMappingURL=EyeglassModule.js.map