import { SimpleCache } from "../util/SimpleCache";
import EyeglassModule, { ModuleSpecifier } from "./EyeglassModule";
import { IEyeglass } from "../IEyeglass";
import { SassImplementation } from "../util/SassImplementation";
import { Dict } from "../util/typescriptUtils";
import { EyeglassConfig } from "..";
import { Config } from "../util/Options";
export declare const ROOT_NAME = ":root";
declare type ModuleMap = Dict<EyeglassModule>;
interface DependencyVersionIssue {
    name: string;
    left: EyeglassModule;
    right: EyeglassModule;
}
interface ModuleBranch {
    name: string;
    version: string | undefined;
    path: string;
    dependencies: Dict<ModuleBranch> | undefined;
}
/**
  * Discovers all of the modules for a given directory
  *
  * @constructor
  * @param   {String} dir - the directory to discover modules in
  * @param   {Array} modules - the explicit modules to include
  * @param   {Boolean} useGlobalModuleCache - whether or not to use the global module cache
  */
export default class EyeglassModules {
    issues: {
        dependencies: {
            versions: Array<DependencyVersionIssue>;
            missing: Array<string>;
        };
        engine: {
            missing: Array<EyeglassModule>;
            incompatible: Array<EyeglassModule>;
        };
    };
    cache: {
        access: SimpleCache<boolean>;
        modules: SimpleCache<EyeglassModule | undefined>;
        modulePackage: SimpleCache<string | undefined>;
    };
    collection: ModuleMap;
    list: Array<EyeglassModule>;
    tree: ModuleBranch;
    projectName: string;
    eyeglass: EyeglassModule;
    config: Config;
    private _modulePathMap;
    constructor(dir: string, config: EyeglassConfig, modules?: Array<ModuleSpecifier>);
    /**
      * initializes all of the modules with the given engines
      *
      * @param   {Eyeglass} eyeglass - the eyeglass instance
      * @param   {Function} sass - the sass engine
      */
    init(eyeglass: IEyeglass, sass: SassImplementation): void;
    /**
      * Checks whether or not a given location has access to a given module
      *
      * @param   {String} name - the module name to find
      * @param   {String} origin - the location of the originating request
      * @returns {Object} the module reference if access is granted, null if access is prohibited
      */
    access(name: string, origin: string): EyeglassModule | null;
    /**
      * Finds a module reference by the module name
      *
      * @param   {String} name - the module name to find
      * @returns {Object} the module reference
      */
    find(name: string): EyeglassModule | undefined;
    /**
     * Creates, caches and returns a mapping of filesystem locations to eyeglass
     * modules.
     */
    readonly modulePathMap: Dict<EyeglassModule>;
    /**
     * Finds the most specific eyeglass module that contains the given filesystem
     * location. It does this by walking up the directory structure and looking
     * to see if it finds the main directory of an eyeglass module.
     */
    findByPath(location: string): EyeglassModule | null;
    /**
      * Returns a formatted string of the module hierarchy
      *
      * @returns {String} the module hierarchy
      */
    getGraph(): string;
    /**
      * resolves the module and it's dependencies
      *
      * @param   {String} pkgPath - the path to the modules package.json location
      * @param   {Boolean} isRoot - whether or not it's the root of the project
      * @returns {Object} the resolved module definition
      */
    private resolveModule;
    /**
      * dedupes a collection of modules to a single version
      *
      * @this {EyeglassModules}
      *
      * @param   {Object} module - the collection of modules
      * @returns {Object} the deduped module collection
      */
    private dedupeModules;
    /**
      * checks for any issues in the modules we've discovered
      *
      * @this {EyeglassModules}
      *
      */
    private checkForIssues;
    private isCompatibleWithThisEyeglass;
    /**
      * rewrites the module tree to reflect the deduped modules
      *
      * @this {EyeglassModules}
      *
      * @param  {Object} moduleTree - the tree to prune
      * @returns {Object} the pruned tree
      */
    private pruneModuleTree;
    /**
      * resolves the eyeglass module itself
      *
      * @returns {Object} the resolved eyeglass module definition
      */
    private getEyeglassSelf;
    /**
      * discovers all the modules for a given set of options
      *
      * @param    {Object} options - the options to use
      * @returns  {Object} the discovered modules
      */
    private discoverModules;
    /**
      * resolves the package for a given module
      *
      * @see resolve()
      */
    private resolveModulePackage;
    /**
      * gets the final module from the collection
      *
      * @this {EyeglassModules}
      *
      * @param   {String} name - the module name to find
      * @returns {Object} the module reference
      */
    private getFinalModule;
    /**
      * gets the root name and decorates it
      *
      * @this {EyeglassModules}
      *
      * @returns {String} the decorated name
      */
    private getDecoratedRootName;
    /**
      * whether or not a module can be accessed by the origin request
      *
      * @this {EyeglassModules}
      *
      * @param   {String} name - the module name to find
      * @param   {String} origin - the location of the originating request
      * @returns {Boolean} whether or not access is permitted
      */
    private canAccessModule;
}
export {};
//# sourceMappingURL=EyeglassModules.d.ts.map