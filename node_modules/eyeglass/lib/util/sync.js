/**
 * Custom function wrapper to ensure sync/async compatibility
 * ---
 * In the docs for render() and renderSync(), custom functions behave
 * differently. However, we want eyeglass custom functions to act just like
 * importers, always receiving an optional `done()` argument at the end. A
 * developer can either asynchronously call `done()` or they can return a
 * value in a synchronous manner.
 *
 * To make this work, we rely on the `deasync` library to turn an event loop
 * while holding a C level `sleep()` open. This allows an async function to
 * resolve without having to run a fiber through the entire node-sass project.
 *
 * The original problem and solution can be found on stack overflow:
 * http://stackoverflow.com/questions/21819858/how-to-wrap-async-function-
 * calls-into-a-sync-function-in-node-js-or-javascript
 */
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var deasync = require("deasync");
var makeSync = function (fn) {
    return function () {
        var result;
        var args = new (Array.bind.apply(Array, __spread([void 0], arguments)))();
        var last = args[args.length - 1];
        // last arg is a function (async capture)
        if (typeof last === "function") {
            return fn.apply(this, args);
        }
        // last arg is not a function (synchronous mode)
        // for some reason, there is a bridge object that shouldn't be on the args
        // replace it with our custom callback
        // turn the loop once, and then begin blocking until we resolve
        function cb(res) {
            setTimeout(function () {
                result = res;
            }, 0);
        }
        args.pop(); // bridge object BAD
        args.push(cb); // capture callback GOOD
        result = fn.apply(this, args);
        if (result !== undefined) {
            return result;
        }
        while (result === undefined) {
            deasync.runLoopOnce();
        }
        return result;
    };
};
function all(obj) {
    var syncAll = {};
    for (var name in obj) {
        syncAll[name] = sync(obj[name]);
    }
    return syncAll;
}
var sync = Object.assign(makeSync, { all: all });
exports.default = sync;
//# sourceMappingURL=sync.js.map