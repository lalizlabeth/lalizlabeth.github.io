"use strict";
var Eyeglass_1 = require("./Eyeglass");
/* eslint-disable @typescript-eslint/no-namespace, no-inner-declarations, no-redeclare */
function deprecateMethodWarning(method) {
    this.deprecate("0.8.0", "0.9.0", "`require('eyeglass')." + method + "` is deprecated. " +
        "Instead, use `require('eyeglass')`");
}
// This is how we convince typescript that there's an object that is
// both a constructor and a function that returns options.
function newOrOptions() {
    var __Eyeglass = function (options, deprecatedNodeSassArg) {
        var instance = new Eyeglass_1.default(options, deprecatedNodeSassArg);
        if (this) {
            // the implicit this object is thrown away :engineer-shrugging:
            return instance;
        }
        else {
            return instance.options;
        }
    };
    __Eyeglass.prototype = Eyeglass_1.default.prototype;
    __Eyeglass.VERSION = Eyeglass_1.default.VERSION;
    __Eyeglass.helpers = Eyeglass_1.default.helpers;
    Object.assign(__Eyeglass, {
        Eyeglass: function (options, deprecatedNodeSassArg) {
            var eyeglass = new Eyeglass_1.default(options, deprecatedNodeSassArg);
            deprecateMethodWarning.call(eyeglass, "Eyeglass");
            return eyeglass;
        },
        decorate: function (options, deprecatedNodeSassArg) {
            var eyeglass = new Eyeglass_1.default(options, deprecatedNodeSassArg);
            deprecateMethodWarning.call(eyeglass, "decorate");
            return eyeglass.options;
        }
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return __Eyeglass; // we have to cast through any otherwise typescript thinks this function doesn't implement the full API of EyeglassImpl.
}
var Eyeglass = newOrOptions();
module.exports = Eyeglass;
/* eslint-enable @typescript-eslint/no-namespace */
//# sourceMappingURL=index.js.map